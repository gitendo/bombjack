[{"body":"\rto my personal Bomb Jack documentation project based on software disassembly, reverse engineering and other available sources.\nYou\u0026rsquo;ve probably dissected Bomb Jack along with Andre Weissflog. If not I really recommend reading it. Instead of emulating the game I\u0026rsquo;ve been digging into the software side to figure out inner workings and hidden secrets of this instant classic.\nMy final goal is to provide working assembly source, ready for possible improvements. This is ongoing exploration project and might not be completed.\nCurrent progress:\ndisassembly (not public yet) reverse engineering (WIP) documentation (WIP) Explore\n","link":"https://gitendo.github.io/bombjack/","section":"","title":"Welcome"},{"body":"The following table shows a short overview of Bomb Jack memory map as seen and used by Z80.\nAddress Size Type Access Description $0000 $1FFF ROM RO 09_j01b.bin $2000 $3FFF ROM RO 10_101b.bin $4000 $5FFF ROM RO 11_m01b.bin $6000 $7FFF ROM RO 12_n01b.bin $8000 $0FFF RAM RW general purpose RAM $9000 $03FF VRAM RW character map $9400 $03FF VRAM RW attribute map $9820 $005F VRAM WO object attribute memory $9A00 / $9A01 - I/O WO object size select $9C00 $00FF CRAM WO color palette memory $9E00 - I/O WO background picture select $B000 - I/O RW joystick 1 and NMI $B001 - I/O RO joystick 2 $B002 - I/O RO coins acceptors nd start buttons $B003 - I/O RW watchdog reset $B004 - I/O RW dip switch 1 and screen flip $B005 - I/O RO dip switch 2 $B006 - I/O RW sound latch $C000 $1FFF ROM RO 13.1r ","link":"https://gitendo.github.io/bombjack/memory_map/","section":"","title":"Memory Map"},{"body":"Character map combined with attribute map creates BG_1 - second of the three layers of graphics.\n$9000 - $93FF (Read/Write)\nüí° Columns are being stored in RAM from right to left. First visible column starts at $93A0 and ends at $93BF. Last visible column starts at $9040 and ends at $905F respectively. These are also addresses for top left, bottom left, top right and bottom right characters visible on the layer.\nBG_1 is used for text, bottom part of title screen logo, HUD, stage borders, platforms and bombs. It has priority above BG_0 but below OBJ. Main features are:\narray of 32 columns, 32 rows each each entry is 1 byte and represents 1 character code (8x8 pixel block also called tile) from bank 0 up to 512 unique characters is possible thanks to corresponding attribute map entry first and last two columns remain off screen (screen resolution is 224*256) ","link":"https://gitendo.github.io/bombjack/character_map/","section":"","title":"Character Map"},{"body":"Attribute map is strictly related to character map, both are used to create BG_1 layer.\n$9400 - $97FF (Read/Write)\nüí° Columns are being stored in RAM from right to left. First visible column starts at $97A0 and ends at $97BF. Last visible column starts at $9440 and ends at $945F respectively. These are also addresses for top left, bottom left, top right and bottom right attributes of characters visible on the layer.\nMain purpose of attribute map is to provide additional features to character map. While character map entry defines character (tile) code to be put on the BG_1 layer, related attribute map entry does the following:\nbits 0 to 3 define palette (0-15) to be used with such character bit 4 selects character slot to choose from: (0) lower (characters from 0 to 255) or (1) upper (characters from 256 to 511) bits from 5 to 7 seem to be unused Other than that it has features identical to character map:\narray of 32 columns, 32 rows each each entry is 1 byte and corresponds to related character map entry first and last two columns remain off screen (screen resolution is 224*256) ","link":"https://gitendo.github.io/bombjack/attribute_map/","section":"","title":"Attribute Map"},{"body":"Object attribute memory holds the information about objects (also reffered as sprites) to be displayed. It creates last of the three layers of graphics.\n$9820 - $987F (Write Only)\nüí° OAM mirror is stored in RAM at $8500 where it\u0026rsquo;s being freely manipulated. OAM update is done during VBLANK - this prevents glitches and is commonly used method.\nObjects are stored in character format but can be moved independently and displayed anywhere on the screen. They have the highest priority and are displayed over BG_1 which is displayed over BG_0. Hardware supports two object sizes: 16*16 and 32*32 pixels. Each object has its own palette applied and might be flipped horizontally or vertically. Obviously, there\u0026rsquo;s display and storage limit:\nas for display, it\u0026rsquo;s 384 pixels per scan line which translates to 24 objects (16*16 pixels) or 12 objects (32*32 pixels). It\u0026rsquo;s possible to have objects of mixed sizes but the limit still applies (consider one 32*32 as two 16*16 objects to make things easier). Multiplexing also works (this has been already proven by Martin Piper) although there\u0026rsquo;s no register that provides information about current scan line being processed.\nthere\u0026rsquo;re 1024 characters to be used for storage of object graphics. One 16*16 object uses four of them and 32*32 uses sixteen. This gives room to 256 objects of 16*16 size or 64 objects of 32*32 size. Different sizes could be stored interchangeably but this requires some planning. Object character data is seen by the hardware as 2 banks which affects directly how they\u0026rsquo;re bing selected.\nTo create an object there must be valid entry in OAM - please refer to the table on the right. The order is related to display priority: low to high.\nAs you can tell, 16*16 object entries must be aligned to 4 byte boundary while 32*32 objects to 8 byte boundary. In the latter case each OAM entry should be followed by four zero bytes.\nSince OAM entry doesn\u0026rsquo;t contain any information about object size another thing specific to 32*32 objects is usage of size select registers. This is explained in details in it\u0026rsquo;s own chapter.\nOAM Address 16*16 OBJ 32*32 OBJ $9820 1 1 $9824 2 $9828 3 2 $982C 4 $9830 5 3 $9834 6 - - - $9878 23 12 $987C 24 Finally here\u0026rsquo;s the entry itself. It consists of 4 bytes with their bits having the following meaning:\nByte Bits Description 1 7 toggles between lower (0) and upper (1) bank where object graphics is stored 6 - 0 object id (0-127) in case of 16*16 and (0-31) for 32*32 objects 2 7 flips object horizontally 6 flips object vertically 5 not used by hardware (used by software to tag 32*32 objects) 4 not used by hardware 3 - 0 object palette id (0-15) 3 7 - 0 object x coordinate 4 7 - 0 object y coordinate ","link":"https://gitendo.github.io/bombjack/object_memory/","section":"","title":"Object Attribute Memory"},{"body":"Size select registers define how many and which entries in OAM are displayed as 32*32 objects.\n‚ö†Ô∏è The following information is partly based on the research done by Martin Piper and it\u0026rsquo;s not properly emulated by MAME as of the time of writing.\n$9A00 (Write Only)\n$9A01 (Write Only)\nüí° Both registers accept values from 0 to 15 however values from 0 to 3 do not provide any result.\nDuring initial setup memory from $9A00 to $9AC8 is zero filled by code at $015F. It\u0026rsquo;s currently unknown why such large block is used.\nEven though single OAM entry contains a lot of information it doesn\u0026rsquo;t specify the object size. All entries are assumed to be 16*16 objects by default and no additional action is required. To display one or more of 32*32 objects the forementioned registers are used. Four combinations are possible:\nMode Requirements 16*16 objects only Set both registers to $00 value. This causes every OAM entry out of 24 available to be displayed as 16*16. 32*32 objects only Set $9A00 to $0F and $9A01 to $00. Every OAM entry out of 12 possible is displayed as 32*32. 16*16 and 32*32 objects (ordered) Set $9A00 register with number of 32*32 objects increased by 3. Write all 32*32 entries before 16*16 ones during OAM update. If the number of 32*32 objects changes dynamically also update $9A00 register. This is roughly what game code does at $0958. 16*16 and 32*32 objects (mixed) Use $9A00 as start and $9A01 as end parameter. start points to the first OAM entry to be displayed as 32*32 object while end points to entry following the last one to be displayed as such. Both parameters must be in 1-12 range and then increased by 3 before writing. While first two modes are straightforward let\u0026rsquo;s review the original code located at $0958:\noam_update:\r\u0026amp;nbsp;\tld ix, $9878\t; VRAM: OAM last entry (dst for 16*16 obj)\r\u0026amp;nbsp;\tld iy, $9820\t; VRAM: OAM first entry (dst for 32*32 obj)\r\u0026amp;nbsp;\tld hl, $8500\t; RAM: OAM mirror (src)\r\u0026amp;nbsp;\tld b, $0C ; 12 objects * 8 (4 byte entry followed by 4 zeroes ) = OAM size\r\u0026amp;nbsp;\tld c, 3\t; 32*32 obj counter (starts from 3 because values 0-3 have no effect on $9A00)\r_next:\r\u0026amp;nbsp;\tld a, b\t; all 12 objects processed?\r\u0026amp;nbsp;\tcp 0\r\u0026amp;nbsp;\tjr z, _done ; yes\r\u0026amp;nbsp;\tinc hl ; skip 1st byte of OAM entry (obj id)\r\u0026amp;nbsp;\tld a, (hl) ; get 2nd byte (obj attribute)\r\u0026amp;nbsp;\tdec hl ; move back to 1st byte (obj id)\r\u0026amp;nbsp;\tbit 5, a ; it\u0026#39;s 32*32 object if 5th bit is set\r\u0026amp;nbsp;\tjr nz, _obj32\r_obj16:\t; 16*16\r\u0026amp;nbsp;\tcall $0982\t; de = ix, copy 8 bytes from (hl) to (de), ix - 8, b - 1\r\u0026amp;nbsp;\tjr _next\r_obj32:\t; 32*32\r\u0026amp;nbsp;\tcall $0996\t; de = iy, copy 8 bytes from (hl) to (de), iy + 8, b - 1, c + 1\r\u0026amp;nbsp;\tjr _next\r_done:\t; sorting \u0026amp; update finished\r\u0026amp;nbsp;\tld a, c\t; 32*32 object count\r\u0026amp;nbsp;\tld ($9A00), a ; tell the hardware how many 32*32 objects are in OAM, starting from 1st entry\r\u0026amp;nbsp;\tret This approach simply limits the total number of objects being used in game to 12, avoiding the trouble of using $9A01 register. Each OAM entry is aligned to 8 byte boundary. Additional 4 bytes are usually zero filled (empty entry) however backup of x/y coordinates related to given entry might be found sometimes there. This has no visible effect anyway. 32*32 entries are stored (forward) from the beginning and 16*16 entries (backward) from the end of OAM. At exit $9A00 register is updated with value equal to number of 32*32 entries increased by 3.\nUsing mixed method is somewhat trickier to understand. It doesn\u0026rsquo;t require 32*32 entries to be stored at the beginning of the OAM, they must form continuous block nonetheless. Single 16*16 and 32*32 entries can\u0026rsquo;t be stored interchangeably - please refer to examples below. While it might seem confusing the whole start / end assignment is only for explanation purpose. As long as both values are right it doesn\u0026rsquo;t matter which register is loaded with which value, because result is the same. Only equal values have no effect. All possible register combinations have been tested by Martin Piper and can be viewed here.\n(1,2) $9A00 = $04, $9A01 = $05\nOAM Address 16*16 OBJ 32*32 OBJ $9820 0 $9824 1 $9828 1 $982C $9830 4 $9834 5 $9838 6 $983C 7 $9840 8 $9844 9 $9848 10 $984C 11 $9850 12 $9854 13 $9858 14 $985C 15 $9860 16 $9864 17 $9868 18 $986C 19 $9870 20 $9874 21 $9878 22 $987C 23 (9,3) $9A00 = $0C, $9A01 = $06\nOAM Address 16*16 OBJ 32*32 OBJ $9820 0 $9824 1 $9828 2 $982C 3 $9830 4 $9834 5 $9838 3 $983C $9840 4 $9844 $9848 5 $984C $9850 6 $9854 $9858 7 $985C $9860 8 $9864 $9868 18 $986C 19 $9870 20 $9874 21 $9878 22 $987C 23 (4,12) $9A00=$07, $9A01=$0F\nOAM Address 16*16 OBJ 32*32 OBJ $9820 0 $9824 1 $9828 2 $982C 3 $9830 4 $9834 5 $9838 6 $983C 7 $9840 4 $9844 $9848 5 $984C $9850 6 $9854 $9858 7 $985C $9860 8 $9864 $9868 9 $986C $9870 10 $9874 $9878 11 $987C This makes it quite flexible solution which can be used in a few different ways. As in previous cases it is recommended to update OAM first, then registers if there were any changes in 32*32 objects number.\n","link":"https://gitendo.github.io/bombjack/object_select/","section":"","title":"Object Size Select"},{"body":"Color palette memory holds user defined palettes. They can be applied to characters and objects used to create graphics layers.\n$9C00 - $9CFF (Write Only)\nüí° CRAM has its mirror located at $8C00 where it\u0026rsquo;s freely modified. Just like with OAM, update is recommended during VBLANK to prevent any glitches.\nColor palette memory is organized into 16 slots.\nEach palette occupies one slot. It has 8 colors and each color entry takes 2 bytes, being represented by 12-bit BGR value. Unused bits are not set.\nAddress Description $9C00 palette $00 $9C10 palette $01 . . . . . . . . . $9CF0 palette $0F Color 0 of each palette is displayed as transparent for BG_1 and OBJ - they effectively use one color less than BG_0.\nPalettes are independent from graphics data which means any object or character can be assigned any palette and have it modified any time.\nCouple examples:\nwhite (R:255, G:255, B:255) equals to $0FFF orange (R:255, G:119, B:00) equals to $007F. blue (R:0, G:170, B:255) equals to $0FA0. ","link":"https://gitendo.github.io/bombjack/color_memory/","section":"","title":"Color Palette Memory"},{"body":"Use the following ports to read coin acceptor, joystick and button state.\n$B000 (Read) - Joystick 1\n$B001 (Read) - Joystick 2\n$B002 (Read) - Other\rJoystick 1 Right %00000001 Left %00000010 Up %00000100 Down %00001000 Jump %00010000 Joystick 2 Right %00000001 Left %00000010 Up %00000100 Down %00001000 Jump %00010000 Other P1 Coin %00000001 P2 Coin %00000010 P1 Start %00000100 P2 Start %00001000 Joystick 1 port is also used to enable / disable Non Maskable Interrupt.\n‚ö†Ô∏è This is just a guess and has not been verified at the moment of writing.\n$B000 (Write) - NMI On / Off\rWhen NMI happens Z80 starts executing code at $0066 address which writes 0 to the register and jumps to VBLANK procedure. At VBLANK exit it is written with 1 value. This seems to be solution to disable / enable NMI from code. As result another NMI is prevented from happening while VBLANK procedure is being processed.\n","link":"https://gitendo.github.io/bombjack/controller/","section":"","title":"Controller Inputs and NMI"},{"body":"Background picture select register simplifies setting of character and attribute maps for BG_0.\n$9E00 (Write Only)\nüí° Value to be written should have 4th bit set to change the background. It\u0026rsquo;s currently unknown if 3rd bit is also used by the hardware.\nBG_0 and BG_1 share the common concept of character and attribute maps. They\u0026rsquo;re both handled in a different way though. BG_0 holds up to 256 characters, 16*16 pixels each. Character data is divided into 3 bitplanes and stored in the following files:\n06_l08t.bin\n07_n08t.bin\n08_r08t.bin\nGame utilizes 8 backgrounds and the same amount of character maps is stored in 02_p04t.bin file. Each character map is followed by related attribute map, they\u0026rsquo;re 256 bytes each. The order of background maps is as follows:\nID Offset Background $00 $0000 Rome $01 $0200 California $02 $0400 Egypt $03 $0600 Germany $04 $0800 New York $0D $0A00 Empty $0E $0C00 Bonus (gold) $0F $0E00 Bonus (silver) The IDs are used in game data structures and code. Shift of the last three ($0D-$08=$05) is made to distinguish these maps by the procedure at $6326. They require just one palette slot while others need two, differently located. This seems to be code not hardware dependent but needs futher analysis.\rAll attribute maps use just two color palette slots: $08 and $0A which restricts background pictures to 16 colors. Only horizontal fliping is possible - attribute\u0026rsquo;s 7th bit is used for such purpose. The process of setting chosen background is as simple as writing palette data to correct palette slot(s) and then use one of eight possible IDs. Before writing to register 4th bit of the ID must be set. Everything else is taken care of by hardware itself. Please refer to original code, located at $639A:\nset_bg_picture:\r\u0026amp;nbsp;\tld a, ($8985) ; check flag (update bg picture and palette)\r\u0026amp;nbsp;\tor a\r\u0026amp;nbsp;\tret z ; quit\r\u0026amp;nbsp;\tld a, ($8986)\t; get background picture id\r\u0026amp;nbsp;\tcp $10\t; leftover code?\r\u0026amp;nbsp;\tjp z, _skip ; \u0026amp;nbsp;\tpush af\t; keep id\r\u0026amp;nbsp;\tld hl, $8C70 ; RAM: palette data src\r\u0026amp;nbsp;\tld de, $9C70 ; CRAM: palette data dst\r\u0026amp;nbsp;\tld bc, $40 ; 4 palettes (bonus box, bg picture bottom half, platforms and border, bg picture top half)\r\u0026amp;nbsp;\tldir ; copy from (hl) to (de)\r\u0026amp;nbsp;\tpop af\t; restore id\r_skip:\r\u0026amp;nbsp;\tset 4, a ; \u0026amp;nbsp;\tld ($9E00), a ; background select register (write only)\r\u0026amp;nbsp;\tld a, 0 ; update finished\r\u0026amp;nbsp;\tld ($8985), a\t; reset flag\r\u0026amp;nbsp;\tret While definately convenient, this unfortunately comes at a price of static and limited backgrounds - it\u0026rsquo;s not possible to modify BG_0 just like BG_1. There\u0026rsquo;s no vertical flipping which could help to conserve character data memory.\n","link":"https://gitendo.github.io/bombjack/background_select/","section":"","title":"Background Picture Select"},{"body":"Bomb Jack PCB has two dip switches to configure game settings. How the game accesses and makes use of them is explained right here.\nDS_1 $B004 (Read/Write)\nDS_1 value can be read from $B004. It\u0026rsquo;s being mirrored in RAM at $8013 and used accordingly. Factory DS_1 settings are: %11000000 which translates to demo sound on and upright mode.\nüí° While $B004 seems like read only it actually is writable. Function at $4587 checks for two player game and when the mode is set to cocktail it writes 1 to flip the screen for player two and 0 back for player one.\nDemo sound\rOff %00000000 On %10000000 Mode\rCocktail %00000000 Upright %01000000 Lives\r3 %00000000 4 %00010000 5 %00100000 2 %00110000 Coin 2\r1 Coin - 1 Credit %00000000 2 Coins - 1 Credit %00000100 1 Coin - 2 Credits %00001000 1 Coin - 3 Credits %00001100 Coin 1\r1 Coin - 1 Credit %00000000 1 Coin - 2 Credits %00000001 1 Coin - 3 Credits %00000010 1 Coin - 6 Credits %00000011 DS_2 $B005 (Read Only)\nDS_2 value can be read from $B005. It\u0026rsquo;s being mirrored in RAM at $8014 and used accordingly. Factory defaults for DS_2 are: %01010000 which translates to high special coin ratio, hard difficulty and bird moving fast.\nüí° On the contrary to DS_1 it is read only however it holds its own secret. According to manual, first three bits / switches are unused and should be turned off. But if you enable function at $5A07 by replacing $C9 (ret) with $F5 (push af) you\u0026rsquo;ll get access to unused \u0026ldquo;Extra lives\u0026rdquo; setting.\nSpecial coin appearance ratio\rHigh %00000000 Low %10000000 Enemy numbers and speed\rEasy %00100000 Medium %00000000 Hard %01000000 Hardest %01100000 Extra lives\rNone %00000000 100K Only %00000100 100K and 300K %00000110 50K Only %00000011 50K and 100K %00000101 50K, 100K and 300K %00000111 Every 100K %00000001 Every 30K %00000010 Bird speed\rSlow %00000000 Normal %00001000 Fast %00010000 Fastest %00011000 ","link":"https://gitendo.github.io/bombjack/dip_switch/","section":"","title":"Dip Switch Settings"},{"body":"Here are external sources I\u0026rsquo;ve found useful and I\u0026rsquo;ve used in this project:\nBomb Jack at Strategy Wiki\nInstruction manual\nBomb Jack driver by Mirko Buffoni\n","link":"https://gitendo.github.io/bombjack/sources/","section":"","title":"Sources"},{"body":"","link":"https://gitendo.github.io/bombjack/categories/","section":"categories","title":"Categories"},{"body":"","link":"https://gitendo.github.io/bombjack/tags/","section":"tags","title":"Tags"}]